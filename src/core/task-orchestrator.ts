import { AICodeGenerator } from './ai-code-generator';
import { GitHubIntegration } from '../integrations/github';
import { Task, CodeGenerationRequest, RepositoryTarget } from '../types';
import { generateTaskId, generateBranchName, formatRepositoryString } from '../utils/config';

export class TaskOrchestrator {
  private aiGenerator: AICodeGenerator;
  private githubToken: string;
  private workingDirBase: string;
  private defaultRepoTarget: RepositoryTarget;
  private tasks: Map<string, Task>;
  private githubInstances: Map<string, GitHubIntegration>;

  constructor(
    anthropicApiKey: string,
    githubToken: string,
    defaultRepoTarget: RepositoryTarget,
    workingDirBase: string,
    anthropicModel?: string
  ) {
    this.aiGenerator = new AICodeGenerator(anthropicApiKey, anthropicModel);
    this.githubToken = githubToken;
    this.defaultRepoTarget = defaultRepoTarget;
    this.workingDirBase = workingDirBase;
    this.tasks = new Map();
    this.githubInstances = new Map();
  }

  async initialize(): Promise<void> {
    console.log('Initializing TaskOrchestrator...');
    // Initialize default repository
    const github = await this.getGitHubIntegration(this.defaultRepoTarget);
    await github.initializeRepository(this.defaultRepoTarget.baseBranch);
    console.log('TaskOrchestrator initialized successfully');
  }

  private async getGitHubIntegration(repoTarget: RepositoryTarget): Promise<GitHubIntegration> {
    const key = `${repoTarget.owner}/${repoTarget.repo}`;

    if (!this.githubInstances.has(key)) {
      const workingDir = `${this.workingDirBase}/${repoTarget.owner}-${repoTarget.repo}`;
      const github = new GitHubIntegration(
        this.githubToken,
        repoTarget.owner,
        repoTarget.repo,
        workingDir
      );
      this.githubInstances.set(key, github);
    }

    return this.githubInstances.get(key)!;
  }

  async executeTask(
    description: string,
    requestedBy: string,
    repoTarget: RepositoryTarget,
    taskType: Task['type'] = 'feature'
  ): Promise<Task> {
    const taskId = generateTaskId();
    const branchName = generateBranchName(description);

    const task: Task = {
      id: taskId,
      description,
      type: taskType,
      status: 'pending',
      requestedBy,
      createdAt: new Date(),
      branch: branchName,
      baseBranch: repoTarget.baseBranch,
      repository: formatRepositoryString(repoTarget.owner, repoTarget.repo),
    };

    this.tasks.set(taskId, task);
    console.log(
      `Created task ${taskId}: ${description} for ${repoTarget.owner}/${repoTarget.repo}`
    );

    try {
      // Update status
      task.status = 'in_progress';
      this.tasks.set(taskId, task);

      // Get or create GitHub integration for this repository
      const github = await this.getGitHubIntegration(repoTarget);

      // Initialize repository if needed
      try {
        await github.initializeRepository(repoTarget.baseBranch);
      } catch (error) {
        console.log('Repository already initialized or initialization failed, continuing...');
      }

      // Create a new branch
      await github.createBranch(branchName, repoTarget.baseBranch);

      // Prepare code generation request
      const request: CodeGenerationRequest = {
        instruction: description,
        taskType,
      };

      // Generate code using AI
      console.log(`Generating code for task ${taskId}...`);
      const result = await this.aiGenerator.generateCode(request);

      if (!result.success) {
        throw new Error(result.error || 'Code generation failed');
      }

      // Apply changes to the repository
      if (result.files && result.files.length > 0) {
        console.log(`Applying ${result.files.length} file changes...`);
        await github.applyChanges(result);

        // Commit and push changes
        const commitMessage = `AI: ${description}\n\nGenerated by ShipIt AI\n${result.explanation || ''}`;
        await github.commitAndPush(commitMessage, branchName);

        // Create pull request
        const prTitle = `[AI] ${description}`;
        const prBody = `## AI-Generated Changes
        
**Task ID:** ${taskId}
**Requested by:** ${requestedBy}
**Task Type:** ${taskType}
**Repository:** ${repoTarget.owner}/${repoTarget.repo}
**Target Branch:** ${repoTarget.baseBranch}

### Description
${description}

### Changes Made
${result.explanation || 'AI-generated code changes'}

### Files Modified
${result.files.map((f) => `- ${f.action.toUpperCase()}: \`${f.path}\``).join('\n')}

---
*This PR was automatically generated by ShipIt AI*`;

        const prUrl = await github.createPullRequest(
          prTitle,
          prBody,
          branchName,
          repoTarget.baseBranch
        );

        // Update task with PR URL
        task.pullRequestUrl = prUrl;
      } else {
        console.log('No files were generated. Creating informational PR...');

        const prTitle = `[AI] ${description}`;
        const prBody = `## AI Response

**Task ID:** ${taskId}
**Requested by:** ${requestedBy}
**Repository:** ${repoTarget.owner}/${repoTarget.repo}

### Request
${description}

### AI Response
${result.explanation || result.generatedCode || 'No code changes required'}

---
*This response was automatically generated by ShipIt AI*`;

        const prUrl = await github.createPullRequest(
          prTitle,
          prBody,
          branchName,
          repoTarget.baseBranch
        );
        task.pullRequestUrl = prUrl;
      }

      // Mark as completed
      task.status = 'completed';
      task.completedAt = new Date();
      this.tasks.set(taskId, task);

      console.log(`Task ${taskId} completed successfully`);
      return task;
    } catch (error) {
      console.error(`Task ${taskId} failed:`, error);
      task.status = 'failed';
      task.error = error instanceof Error ? error.message : 'Unknown error';
      task.completedAt = new Date();
      this.tasks.set(taskId, task);

      return task;
    }
  }

  getTask(taskId: string): Task | undefined {
    return this.tasks.get(taskId);
  }

  getAllTasks(): Task[] {
    return Array.from(this.tasks.values());
  }

  async cleanupMergedBranches(repoTarget: RepositoryTarget): Promise<{
    deletedBranches: string[];
    cleanedTasks: string[];
    errors: string[];
  }> {
    const result = {
      deletedBranches: [] as string[],
      cleanedTasks: [] as string[],
      errors: [] as string[],
    };

    try {
      const github = await this.getGitHubIntegration(repoTarget);

      // Get list of merged branches
      console.log(`Checking for merged branches in ${repoTarget.owner}/${repoTarget.repo}...`);
      const mergedBranches = await github.listMergedBranches(repoTarget.baseBranch);
      console.log(`Found ${mergedBranches.length} merged branches`);

      // Delete each merged branch
      for (const branchName of mergedBranches) {
        try {
          await github.deleteBranch(branchName);
          result.deletedBranches.push(branchName);

          // Clean up associated tasks
          const repoString = formatRepositoryString(repoTarget.owner, repoTarget.repo);
          for (const [taskId, task] of this.tasks.entries()) {
            if (
              task.branch === branchName &&
              task.repository === repoString &&
              task.status === 'completed'
            ) {
              this.tasks.delete(taskId);
              result.cleanedTasks.push(taskId);
              console.log(`Cleaned up task ${taskId} for branch ${branchName}`);
            }
          }
        } catch (error) {
          const errorMsg = `Failed to delete branch ${branchName}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          console.error(errorMsg);
          result.errors.push(errorMsg);
        }
      }

      console.log(
        `Cleanup complete: ${result.deletedBranches.length} branches deleted, ${result.cleanedTasks.length} tasks cleaned`
      );
    } catch (error) {
      const errorMsg = `Failed to cleanup merged branches: ${error instanceof Error ? error.message : 'Unknown error'}`;
      console.error(errorMsg);
      result.errors.push(errorMsg);
    }

    return result;
  }

  async cleanup(): Promise<void> {
    for (const github of this.githubInstances.values()) {
      await github.cleanup();
    }
    this.githubInstances.clear();
  }
}
