import { AICodeGenerator } from './ai-code-generator';
import { GitHubIntegration } from '../integrations/github';
import { Task, CodeGenerationRequest } from '../types';
import { generateTaskId, generateBranchName } from '../utils/config';

export class TaskOrchestrator {
  private aiGenerator: AICodeGenerator;
  private github: GitHubIntegration;
  private baseBranch: string;
  private tasks: Map<string, Task>;

  constructor(
    anthropicApiKey: string,
    githubToken: string,
    githubOwner: string,
    githubRepo: string,
    workingDir: string,
    baseBranch: string,
    anthropicModel?: string
  ) {
    this.aiGenerator = new AICodeGenerator(anthropicApiKey, anthropicModel);
    this.github = new GitHubIntegration(githubToken, githubOwner, githubRepo, workingDir);
    this.baseBranch = baseBranch;
    this.tasks = new Map();
  }

  async initialize(): Promise<void> {
    console.log('Initializing TaskOrchestrator...');
    await this.github.initializeRepository(this.baseBranch);
    console.log('TaskOrchestrator initialized successfully');
  }

  async executeTask(
    description: string,
    requestedBy: string,
    taskType: Task['type'] = 'feature'
  ): Promise<Task> {
    const taskId = generateTaskId();
    const branchName = generateBranchName(description);

    const task: Task = {
      id: taskId,
      description,
      type: taskType,
      status: 'pending',
      requestedBy,
      createdAt: new Date(),
      branch: branchName,
    };

    this.tasks.set(taskId, task);
    console.log(`Created task ${taskId}: ${description}`);

    try {
      // Update status
      task.status = 'in_progress';
      this.tasks.set(taskId, task);

      // Create a new branch
      await this.github.createBranch(branchName, this.baseBranch);

      // Prepare code generation request
      const request: CodeGenerationRequest = {
        instruction: description,
        taskType,
      };

      // Generate code using AI
      console.log(`Generating code for task ${taskId}...`);
      const result = await this.aiGenerator.generateCode(request);

      if (!result.success) {
        throw new Error(result.error || 'Code generation failed');
      }

      // Apply changes to the repository
      if (result.files && result.files.length > 0) {
        console.log(`Applying ${result.files.length} file changes...`);
        await this.github.applyChanges(result);

        // Commit and push changes
        const commitMessage = `AI: ${description}\n\nGenerated by ShipIt AI\n${result.explanation || ''}`;
        await this.github.commitAndPush(commitMessage, branchName);

        // Create pull request
        const prTitle = `[AI] ${description}`;
        const prBody = `## AI-Generated Changes
        
**Task ID:** ${taskId}
**Requested by:** ${requestedBy}
**Task Type:** ${taskType}

### Description
${description}

### Changes Made
${result.explanation || 'AI-generated code changes'}

### Files Modified
${result.files.map((f) => `- ${f.action.toUpperCase()}: \`${f.path}\``).join('\n')}

---
*This PR was automatically generated by ShipIt AI*`;

        const prUrl = await this.github.createPullRequest(
          prTitle,
          prBody,
          branchName,
          this.baseBranch
        );

        // Update task with PR URL
        task.pullRequestUrl = prUrl;
      } else {
        console.log('No files were generated. Creating informational PR...');

        const prTitle = `[AI] ${description}`;
        const prBody = `## AI Response

**Task ID:** ${taskId}
**Requested by:** ${requestedBy}

### Request
${description}

### AI Response
${result.explanation || result.generatedCode || 'No code changes required'}

---
*This response was automatically generated by ShipIt AI*`;

        const prUrl = await this.github.createPullRequest(
          prTitle,
          prBody,
          branchName,
          this.baseBranch
        );
        task.pullRequestUrl = prUrl;
      }

      // Mark as completed
      task.status = 'completed';
      task.completedAt = new Date();
      this.tasks.set(taskId, task);

      console.log(`Task ${taskId} completed successfully`);
      return task;
    } catch (error) {
      console.error(`Task ${taskId} failed:`, error);
      task.status = 'failed';
      task.error = error instanceof Error ? error.message : 'Unknown error';
      task.completedAt = new Date();
      this.tasks.set(taskId, task);

      return task;
    }
  }

  getTask(taskId: string): Task | undefined {
    return this.tasks.get(taskId);
  }

  getAllTasks(): Task[] {
    return Array.from(this.tasks.values());
  }

  async cleanup(): Promise<void> {
    await this.github.cleanup();
  }
}
